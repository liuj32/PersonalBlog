# Vite
> 2022.08.02

浏览器支持 ES 模块。

## 快速的服务器启动
背景：基于打包器的方式必须优先抓取并构建整个应用，才能提供服务。

vite通过一开始将应用中的模块区分为`依赖`和`源码`来改进开发服务器启动时间：
* 依赖：某些较大依赖存在很多模块，且一些存在多种模块化格式(ESM、CommonJS)。
       使用 esbuild 预构建依赖。

* 源码：并非所有都是JavaScript文件，需要进行转换。且不是所有的源码都需要同时被加载(例如基于路由拆分的代码模块)。
       vite只需在浏览器请求源码时进行转换并按需提供源码（vite以原生ESM方式提供源码）。

### 预构建目的(依赖预构建)
1. 先将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM。
2. 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。

使用esbuild来将依赖转为ESM模块。


## 缓慢的更新
传统的热更新也会随着应用规模的增长而显著下降。

vite：
1. 使已编辑的模块与其最近的 HMR 边界之间的链失活。
2. 利用HTTP头加速整个页面的重新加载。
   源码模块请求利用304协商缓存，依赖模块请求同过Cache-Control: max-age=31536000,immutable 进行强缓存。


## 为什么生产环境仍需打包
1. 由于嵌套导入会导致额外的网络往返，生产环境发布未打包的ESM仍效率低下。
2. 为了获得最佳的加载性能，最好将代码tree-shaking、懒加载和chunk 分割。

## 功能
1. NPM 依赖解析和预构建
   vite将会检测到所有被加载的源文件中此类裸模块导入,并执行以下操作:
   * 预构建
   * 重写导入为合法的 URL

## 构建优化
1. CSS 代码分割
   将异步chunk模块中使用到的css代码抽离出来生成一个单独的文件。

2. 预加载指令生成
   为入口chunk和打包出的html文件中的直接引入生成<link rel="modulepreload"> 指令。

3. 异步 Chunk 加载优化
   使用一个预加载步骤自动重写代码，来分割动态导入调用。

## HMR
* 原理：
  主要是通过WebSocket创建浏览器和服务器的通信监听文件的改变，当文件被修改时，服务端发送消息通知客户端修改相应的代码，客户端对应不同的文件进行不同的操作的更新。

* 过程：
  1、创建一个websocket服务端和client文件，启动服务
  2、通过chokidar监听文件变更
  3、当代码变更后，服务端进行判断并推送到客户端
  4、客户端根据推送的信息执行不同操作的更新

## 为什么使用esbuild?
1. 编译运行 VS 解释运行
2. 多线程 VS 单线程
3. 对构建流程进行了优化，充分利用 CPU 资源

## 关键词
esbuild：esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍，会将纯 CommonJS 依赖转换为 ESM。
冷启动：最开始启动项目。

解释型语言: 边运行边解释。
编译型语言：可以编译为原生代码,在编译的时候都将语言转为机器语言，在启动的时候直接执行即可，在 CPU 密集场景下，Go 更具性能优势。


## 工具对比
webpack冷启动慢：将各个资源打包整合在一起形成 bundle
vite：需要 bundle 打包的过程，直接让浏览器去加载对应的资源

## 疑问？
1. Vite 以 原生 ESM 方式提供源码。这实际上是让浏览器接管了打包程序的部分工作？

## 其他
1. package.json 中开启 type: "module"：文件使用ESM语法。
2. tsc：tsc是一个 TypeScript 编译器，可以把TypeScript 编译成JavaScript， tsc 在把目标文件解析成 AST 之后，会进行两步操作，1: 类型检查 2: AST -> JavaScript 代码。
3. 