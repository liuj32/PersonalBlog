<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <script src="./node.js"></script>
  <script>
var res = []

 function findCombinationSum(residue, start, pre, candidates) {
      console.log('residue', residue, 'start', start,'pre', pre)
        if (residue == 0) {
            // Java 中可变对象是引用传递，因此需要将当前 path 里的值拷贝出来
            res.push([...pre])
            return;
        }
        
        var len = candidates.length
        // 优化添加的代码2：在循环的时候做判断，尽量避免系统栈的深度
        // residue - candidates[i] 表示下一轮的剩余，如果下一轮的剩余都小于 0 ，就没有必要进行后面的循环了
        // 这一点基于原始数组是排序数组的前提，因为如果计算后面的剩余，只会越来越小
        for (var i = start; i < len && residue - candidates[i] >= 0; i++) {
            pre.push(candidates[i]);
            // 【关键】因为元素可以重复使用，这里递归传递下去的是 i 而不是 i + 1
            findCombinationSum(residue - candidates[i], i, pre, candidates);
            pre.pop();
        }
    }

function combinationSum(candidates, target){
      var len = candidates.length;
        if (len == 0) {
            return res;
        }
        // 优化添加的代码1：先对数组排序，可以提前终止判断
        candidates = candidates.sort((a, b) => a-b)
        findCombinationSum(target, 0, [], candidates);
}

combinationSum( [2,3,5], 8)
console.log(  res  )
  </script>
</body>
</html>